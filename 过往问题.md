# 网安

## 用udp实现tcp

## arp攻击的原理

arp首先是网络层的协议，用来获得IP地址的MAC地址。有两种攻击方法：

1. arp欺骗，中间人攻击，攻击者向网关和被攻击者都发送arp报文伪造MAC地址，覆盖他们的arp缓存，然后就可以当成中间人拦截篡改数据了
2. arp泛洪，向网络发送大量伪造的arp请求，耗尽交换机的MAC地址表

## DOS攻击

拒接服务攻击。通过发送大量伪造的数据包来消耗服务器的资源，导致服务器没办法正常使用。

## syn泛洪攻击的原理（DDOS）

攻击者伪造大量ip或者控制大量肉鸡，来向服务器发起tcp三次握手中的第一次握手，服务器收到后会分配内存和文件描述符给这个连接，并将其存入半连接队列。攻击者并不回应服务器的syn-ack报文，导致半连接队列越来越长，最后导致正常服务没有办法使用。

## 什么是蜜罐攻击？

蜜罐攻击就是一种诱敌深入的方法，服务器先伪装成容易被入侵的样子，然后记录入侵者的攻击和访问，这样能分析攻击的模式来加强防火墙防御。

## 针对服务器发起的攻击有哪些？

DDOS

SQL注入，XSS跨站脚本攻击，文件上传漏洞

会话劫持（中间人攻击）

0day漏洞

# 数据结构

## git 原理

**其本质上是一个key-value的数据库加上默克尔树形成的有向无环图（DAG）**。

默克尔树：由二叉树构成，叶子节点存储数据块的哈希值，非叶子节点存储其子节点哈希的组合哈希。通过层层哈希计算，最终生成唯一的根哈希值，代表整个数据集合的指纹。

https://www.zhihu.com/search?type=content&q=git%E5%8E%9F%E7%90%86

## 斐波那契数列复杂度

## 有向完全图的边数

n(n - 1)，n为顶点数

## 各种排序算法的时间空间复杂度？

不稳定：**快希选堆**

只用数组：**快希冒堆**

时间复杂度O(nlogn)：**快希归基堆**

空间复杂度不是O(1)的：**快（分成好（O(logn)）、坏（O(n)）），归并（O(n)）**

| 排序算法 | 最好时间复杂度  | 平均时间复杂度    | 最坏时间复杂度  | 空间复杂度               | 稳定性 |
| -------- | --------------- | ----------------- | --------------- | ------------------------ | ------ |
| 冒泡排序 | \(O(n)\)        | \(O(n^2)\)        | \(O(n^2)\)      | \(O(1)\)                 | 稳定   |
| 选择排序 | \(O(n^2)\)      | \(O(n^2)\)        | \(O(n^2)\)      | \(O(1)\)                 | 不稳定 |
| 插入排序 | \(O(n)\)        | \(O(n^2)\)        | \(O(n^2)\)      | \(O(1)\)                 | 稳定   |
| 希尔排序 | \(O(n log n)\)  | 约 \(O(n^{1.3})\) | \(O(n^2)\)      | \(O(1)\)                 | 不稳定 |
| 归并排序 | \(O(n log n)\)  | \(O(n log n)\)    | \(O(n log n)\)  | \(O(n)\)                 | 稳定   |
| 快速排序 | \(O(n log n)\)  | \(O(n log n)\)    | \(O(n^2)\)      | \(O(log n)\) 到 \(O(n)\) | 不稳定 |
| 堆排序   | \(O(n log n)\)  | \(O(n log n)\)    | \(O(n log n)\)  | \(O(1)\)                 | 不稳定 |
| 桶排序   | \(O(n + k)\)    | \(O(n + k)\)      | \(O(n^2)\)      | \(O(n + k)\)             | 稳定   |
| 基数排序 | \(O(d(n + k))\) | \(O(d(n + k))\)   | \(O(d(n + k))\) | \(O(n + k)\)             | 稳定   |

## 排序算法中哪些是稳定排序？至少说三个

冒泡排序、插入排序、归并排序、基数排序、桶排序

## 图里面最小生成树的两种算法，以及两者区别？

prim：当前节点临近最短边，适用于稠密图，O (E log V)

kurskal：最短边，适用于稀疏图，O (E log E)

## 证明dijkstra算法贪心的正确性

用数学归纳法来证明。

1. 起点距离为0，其他节点为无穷大，成立
2. 假设k个节点的最短路径已经确定：选择下一个距离最小的未处理节点，假设存在路径 s→...→v→u 比当前 d [u] 更短，其中 v 未被处理。由于 d [v] ≥ d [u]（贪心选择 u 时 v 未被选），则路径 s→...→v→u 的长度 ≥ d [u]+w (v,u) ≥ d [u]，与假设矛盾。
3. 因此，u 的最短路径已确定，标记为已处理。

## 要优化快速排序有什么好的方法？

1. **随机选择基准元素**：防止递归深度变成O(n)
2. **将部分递归转换成循环**：防止大量数据递归过深，然后栈溢出
3. 用三个指针来处理，一个指向小于pivot的区域的末尾，一个指向大于pivot区域的开头，最后一个用来遍历数组，这样能够**避免重复大量的相同的重复数组**

## 几万的单词如何统计所有字母出现的次数

用哈希表记录每个字母的个数，然后全部遍历一遍所有的单词

## 有几万个字符串，每个字符串是固定的几个字母的组成，怎么统计词频

建一个字典unordered_map，遍历这几万个字符串，遇到字符串，map[string]就加1，若不在map中就新建一个key为这个字符串的key-value对，并设置value为1。

## 图数据库是什么数据结构

图。

## word的Ctrl加F可能使用了什么数据结构

我觉得主要还是使用字符数组，这样能快速访问和遍历。可能使用分块索引，每块分别查询。然后查询的时候使用KMP和BoyerMoore算法。

# 算法

## 海盗分金币问题

## 黑球百球问题

# OS

## 内存什么构成

DRAM+辅助电路（地址译码器，数据缓冲器，时序控制）

## Linux系统的文件系统是什么结构，Linux中OS如何解析一个地址的？

树形结构。从根目录逐层查找inode的编号。

## 内核态，用户态

内核态能够运行内核代码并有所有硬件的访问权限。用户态只能通过系统调用才能使用内核服务。

两者切换主要就是系统调用。

主要为了能隔离用户程序直接运行硬件操作，防止系统被破坏；这样还能又内核同一调度资源。

比如，当用户程序调用`open()`函数打开文件时，会通过系统调用陷入内核态，由内核执行实际的文件打开操作后返回用户态。

## 中断在Linux中的一个使用？

比如一个Linux系统，网卡收到以太网帧，他会实现一次硬件中断，将数据通过DMA拷贝到内存。

然后内核会触发一个软件中断，给内存接收队列中的数据包分配数据包处理例程。

## 死锁产生条件（解决方法）

1. 互斥（SPOOLING技术）
2. 不可剥夺（剥夺资源）
3. 请求并且保持（一次性分配）
4. 循环等待（有序分配）

# CPP

## cin和scanf

## C++模板的优点

代码重用。

类型安全，在编译时就会报错，不会到运行时出错结果难debug。

## 虚函数的底层实现机制

使用一个隐藏的虚函数表指针指向虚函数表，子类继承的时候可以重写虚函数（覆盖了原本的虚函数表中的虚函数指针）。要使用虚函数时就动态地通过虚函数表指针查找这张虚函数表即可。

虚函数是**动态（运行时重载）的**多态，函数/运算符重载是**静态（编译时重载）**的多态

缺点就是每个子类都有虚函数表，越继承这玩意越大，占空间。

## cpp，stl库中的sort函数的底层实现？

sort函数底层是结合了**快速排序、堆排序和插入排序的混合排序算法**。他先快速排序，然后检查递归的深度，如果过于深了，就会转向堆排序。如果数据少于16个就会使用插入排序，这样性能好。

## stl库中的map与unordered_map的区别，以及底层实现机制？

map、set都是使用平衡二叉搜索树（红黑树），key是有序的，时间复杂度都是O(logn)

unordered_map、unordered_set都是用哈希表，key是无序的，时间复杂度都是O(n)

## cpp的反射机制？

反射机制：程序在运行时确定一些对象的类型和属性，这样在运行时候能根据不同的条件调整行为。

使用typeid返回对象的信息，使用dynamic_cast进行安全的向下转型。主要是用这两个在cpp中实现反射机制，具体反射机制不像java、py有现成的，要自己手动实现。

# python

## python的缺点是什么，python为啥现在这么受欢迎

python的缺点是解释性语言，执行效率低。变量运行时确定，可能有什么传参错误之类的问题。内存占用比较大。比较依赖第三方的库。

优点：很好上手。社区比较活跃，生态系统强大，有丰富的库和完善的工具（比如说pip，虚拟环境等等）。

## python中算矩阵的秩是怎么算的

使用奇异值分解，分解为三个矩阵乘积，前后为正交矩阵（列向量和行向量为AA^T^和A^T^A的特征向量），中间为对角矩阵，对角上都是奇异值，可能带小数点不准确，有多少个非零（或者说在0附近设置一个阈值，在这个阈值之外的）的奇异值，就是秩的值

# 机器学习

## 机器学习有哪些经典的算法

## 哪些分类算法

## 介绍一下支持向量机和神经网络模型的速度和精确度差异

## 预训练和预处理

## CNN的特点

## 什么场景下使用SVM更好，什么场景下使用NN好一些？

## 优化器是什么，有哪些优化器

## 解释梯度消失和梯度爆炸

## resnet原理

## rnn为什么梯度消失

## MoE的话可以看一下，毕竟deepseek用了

## AI如何应用在安全领域

比如可以使用CNN/RNN来分析二进制文件/PE头，识别恶意代码特征来分析恶意软件。

利用强化学习模拟程序行为，检测异常操作，LSTM 分类恶意软件

比如可以使用无监督模型检测异常流量。

## bert和gpt的区别

## 最近GPT很火，你对gpt的原理有所了解吗？

## 用没用过chatgpt，觉得chatgpt有什么缺点？

云计算，所以有个人数据泄露的风险，以及云计算资源容易出现高峰时段的访问超载问题。

生成虚假信息，但是显得很真。

# 其他

## 印象最深的一道信息安全题目

## 你为什么做这个项目

## 你做过最印象深刻的project是什么？

## 本科的一次成功的经历,遗憾的经历

## 本科最喜欢的课程

## 看过最高层次的论文是什么

## 最近看了什么论文,复述一下

## 网络安全的顶会有哪些?

CCS（ACM Conference on Computer and Communications Security）

NDSS（Network and Distributed System Security Symposium）

S&P（IEEE Symposium on Security & Privacy）

USENIX（USENIX Security Symposium）

其他还有美密、欧密和亚密

## 优缺点

## 会不会考虑读博士

## 为什么选择这个方向？

## 研究生规划，打算研究什么方向，相关的术语的解释以及有哪些实际应用

## 为什么选择复旦

首先，带我学习编程和可以算作我在计算机领域的领路人学长就来自复旦，他还在邱锡鹏老师的实验室搞过ai，这让我对复旦有了很深的向往。我在高考时离复旦差之毫厘，所以也产生了一定的执念。

其次，复旦毫无疑问是一所优秀的大学，有丰富的资源和较高的平台让我学习成长，能让我有足够的专业能力。

最后就是，作为一个理工科的学生，本科学校也是比较崇尚技术能力的，我其实很想体验一下复旦的人文气息，感受一下“自由而无用”，不过我还是更希望能借着在这里成为一个能够博学而笃志、切问而近思的人。

# 数学

## 矩阵秩的定义，向量组秩的定义

矩阵的秩是其行向量组或列向量组的极大线性无关组的向量个数，向量组的秩是其极大线性无关组的向量个数。

## 范德蒙德行列式

可以用来设计纠错码

## 线性空间（向量空间）的定义

一个线性空间的所有向量应该能用这个空间的基向量线性表示

## 如何判断一个数是不是素数

- **费马小定理**：若 p 是素数，对任意 $a \not\equiv 0 \mod p$，有 $a^{p-1} \equiv 1 \mod p$。
- **二次探测**：若 p 是奇素数，且 $x^2 \equiv 1 \mod p$，则 $x \equiv 1 \mod p$ 或 $x \equiv -1 \mod p$。

### 试除法（不大的素数）

### 线性筛（生成小于n的所有素数）

- **唯一筛除**：每个合数仅被其最小素因子筛除一次。
- **维护素数列表**：遍历每个数 i，若未被标记为合数，则将其加入素数列表。
- **标记合数**：用已找到的素数乘以 i，标记为合数。当 i 能被当前素数整除时，停止筛除，避免重复。

### Fermat 素性检测（大素数，有大概率判断）

1. **输入**：待检测的正整数 n，以及一个可选的参数 k（表示进行检测的次数，k 越大，结果越准确）。
2. **特殊情况处理：**
   - 如果 $n = 2$ 或 $n = 3$，则直接判定 n 为素数。
   - 如果 $1\leq n$ 或者 n 是偶数且 $n\neq2$，则判定 n 为合数。
3. **进行 k 次检测：**
   - 随机选取 k 个整数 a，满足 $1 < a < n - 1$。
   - 对于每个选取的 a，计算 $a^{n - 1}\bmod n$。可以使用**快速幂**算法来高效地计算幂模运算。
   - 如果存在某个 a 使得 $a^{n - 1}\not\equiv1\pmod{n}$，则判定 n 为合数。**（费马小定理）**
   - 如果对于所有选取的 a 都有 $a^{n - 1}\equiv1\pmod{n}$，则判定 n 可能是素数。

### Miller-Rabin素性检测

给定奇数 \(n > 2\)，检测其是否为素数：

1. **分解 \(n-1\)**：将 \(n-1\) 表示为 $d \cdot 2^s$，其中 d 是奇数。
2. **选择随机基数 a**：$2 \leq a < n$。
3. **计算 $x = a^d \mod n$：**
   - 若 $x \equiv 1 \mod n$，通过测试，继续下一个 a。**(费马小定理)**
   - 否则，进行s次平方迭代：
     - 若某次迭代后 $x \equiv -1 \mod n$，通过测试，继续下一个 a。**（二次探测）**
     - 若所有迭代均未得到 $x \equiv -1 \mod n$，则 n 是合数。
4. **重复步骤 2-3**：选择多个不同的 a，若所有测试均通过，则 n 大概率是素数。

| **算法**                | **时间复杂度**    | **空间复杂度** | **适用场景**           | **优缺点**                                 |
| ----------------------- | ----------------- | -------------- | ---------------------- | ------------------------------------------ |
| **线性筛**              | \(O(n)\)          | \(O(n)\)       | 生成范围内所有素数     | 高效生成素数表，但内存受限，无法处理大数。 |
| **试除法**              | \(O(\sqrt{n})\)   | \(O(1)\)       | 小规模素数检测或预处理 | 简单准确，但对大数完全不可行。             |
| **Fermat/Miller-Rabin** | \(O(k \log^3 n)\) | \(O(1)\)       | 大素数快速检测         | 高效且错误率可控，但存在理论误判风险。     |