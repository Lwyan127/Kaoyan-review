# 网安

## 用udp实现tcp

1. 增加**ack机制**，确保能发送到对端
2. 增加**seq机制**，实现**顺序化**传输
3. 需要用**队列实现缓冲区**，主要是为了重传
4. **校验**机制

## arp攻击的原理

arp首先是网络层的协议，用来获得IP地址的MAC地址。有两种攻击方法：

1. arp欺骗，中间人攻击，攻击者向网关和被攻击者都发送arp报文伪造MAC地址，覆盖他们的arp缓存，然后就可以当成中间人拦截篡改数据了
2. arp泛洪，向网络发送大量伪造的arp请求，耗尽交换机的MAC地址表

## DOS攻击

拒接服务攻击。通过发送大量伪造的数据包来消耗服务器的资源，导致服务器没办法正常使用。

## syn泛洪攻击的原理（DDOS）

攻击者伪造大量ip或者控制大量肉鸡，来向服务器发起tcp三次握手中的第一次握手，服务器收到后会分配内存和文件描述符给这个连接，并将其存入半连接队列。攻击者并不回应服务器的syn-ack报文，导致半连接队列越来越长，最后导致正常服务没有办法使用。

## 什么是蜜罐攻击？

蜜罐攻击就是一种诱敌深入的方法，服务器先伪装成容易被入侵的样子，然后记录入侵者的攻击和访问，这样能分析攻击的模式来加强防火墙防御。

## 针对服务器发起的攻击有哪些？

DDOS

SQL注入，XSS跨站脚本攻击，文件上传漏洞

会话劫持（中间人攻击）

0day漏洞

# 数据结构

## git 原理

**其本质上是一个key-value的数据库加上默克尔树形成的有向无环图（DAG）**。

默克尔树：由二叉树构成，叶子节点存储数据块的哈希值，非叶子节点存储其子节点哈希的组合哈希。通过层层哈希计算，最终生成唯一的根哈希值，代表整个数据集合的指纹。

https://www.zhihu.com/search?type=content&q=git%E5%8E%9F%E7%90%86

## 斐波那契数列复杂度

递归调用：

- 时间：O(2^n^)
- 空间：O(n)

记忆化递归（优化）:

- 时间：O(n)
- 空间：O(n)

迭代实现：

- 时间：O(n)
- 空间：O(1)

## 有向完全图的边数

n(n - 1)，n为顶点数

## 各种排序算法的时间空间复杂度？

不稳定：**快希选堆**

只用数组：**快希冒堆**

时间复杂度O(nlogn)：**快希归基堆**

空间复杂度不是O(1)的：**快（分成好（O(logn)）、坏（O(n)）），归并（O(n)）**

| 排序算法 | 最好时间复杂度  | 平均时间复杂度    | 最坏时间复杂度  | 空间复杂度               | 稳定性 |
| -------- | --------------- | ----------------- | --------------- | ------------------------ | ------ |
| 冒泡排序 | \(O(n)\)        | \(O(n^2)\)        | \(O(n^2)\)      | \(O(1)\)                 | 稳定   |
| 选择排序 | \(O(n^2)\)      | \(O(n^2)\)        | \(O(n^2)\)      | \(O(1)\)                 | 不稳定 |
| 插入排序 | \(O(n)\)        | \(O(n^2)\)        | \(O(n^2)\)      | \(O(1)\)                 | 稳定   |
| 希尔排序 | \(O(n log n)\)  | 约 \(O(n^{1.3})\) | \(O(n^2)\)      | \(O(1)\)                 | 不稳定 |
| 归并排序 | \(O(n log n)\)  | \(O(n log n)\)    | \(O(n log n)\)  | \(O(n)\)                 | 稳定   |
| 快速排序 | \(O(n log n)\)  | \(O(n log n)\)    | \(O(n^2)\)      | \(O(log n)\) 到 \(O(n)\) | 不稳定 |
| 堆排序   | \(O(n log n)\)  | \(O(n log n)\)    | \(O(n log n)\)  | \(O(1)\)                 | 不稳定 |
| 桶排序   | \(O(n + k)\)    | \(O(n + k)\)      | \(O(n^2)\)      | \(O(n + k)\)             | 稳定   |
| 基数排序 | \(O(d(n + k))\) | \(O(d(n + k))\)   | \(O(d(n + k))\) | \(O(n + k)\)             | 稳定   |

## 排序算法中哪些是稳定排序？至少说三个

冒泡排序、插入排序、归并排序、基数排序、桶排序

## 图里面最小生成树的两种算法，以及两者区别？

prim：当前节点临近最短边，适用于稠密图，O (E log V)

kurskal：最短边，适用于稀疏图，O (E log E)

## 证明dijkstra算法贪心的正确性

用数学归纳法来证明。

1. 起点距离为0，其他节点为无穷大，成立
2. 假设k个节点的最短路径已经确定：选择下一个距离最小的未处理节点，假设存在路径 s→...→v→u 比当前 d [u] 更短，其中 v 未被处理。由于 d [v] ≥ d [u]（贪心选择 u 时 v 未被选），则路径 s→...→v→u 的长度 ≥ d [u]+w (v,u) ≥ d [u]，与假设矛盾。
3. 因此，u 的最短路径已确定，标记为已处理。

## 要优化快速排序有什么好的方法？

1. **随机选择基准元素**：防止递归深度变成O(n)
2. **将部分递归转换成循环**：防止大量数据递归过深，然后栈溢出
3. 用三个指针来处理，一个指向小于pivot的区域的末尾，一个指向大于pivot区域的开头，最后一个用来遍历数组，这样能够**避免重复大量的相同的重复数组**

## 几万的单词如何统计所有字母出现的次数

用哈希表记录每个字母的个数，然后全部遍历一遍所有的单词

## 有几万个字符串，每个字符串是固定的几个字母的组成，怎么统计词频

建一个字典unordered_map，遍历这几万个字符串，遇到字符串，map[string]就加1，若不在map中就新建一个key为这个字符串的key-value对，并设置value为1。

## 图数据库是什么数据结构

图。

## word的Ctrl加F可能使用了什么数据结构

我觉得主要还是使用字符数组，这样能快速访问和遍历。可能使用分块索引，每块分别查询。然后查询的时候使用KMP和BoyerMoore算法。

# 算法

## 海盗分金币问题

经济学上有个“海盗分金”模型：是说5个海盗抢得100枚金币，他们按抽签的顺序依次提方案：首先由1号提出分配方案，然后5人表决，投票要超过半数同意方案才被通过，否则他将被扔入大海喂鲨鱼，依此类推。

假定“每个海盗都是绝顶聪明且很理智”，那么“第一个海盗提出怎样的分配方案才能够使自己的收益最大化？”

推理过程是这样的：

从后向前推，如果1至3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。

3号知道这一点，就会提出“100，0，0”的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。

不过，2号推知3号的方案，就会提出“98，0，1，1”的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。

同样，2号的方案也会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了。答案是：1号强盗分

## 黑球白球百球问题

**一个袋子里有100个黑球和100个白球，每次从袋子里面取出两个球扔掉，再放入一个特定颜色的球。**

**规则如下：如果取出的两个球颜色相同，则放入袋中一个白球；如果不同，则放入一个黑球。**

**问题：最后剩余的一个球的颜色是黑色还是白色？**

黑球◊黑球=白球

白球◊白球=白球

黑球◊白球=黑球

设黑球为1，白球为0：

1◊1=0

0◊0=0

1◊0=1

则原来的操作抽象为：对100个1和100个0做无序的异或操作。

则(1^ 1 ^ ...^1)[100] ^ (0^ 0^ ...^0)[100]简化为 0^0=0。

故最终剩下白球

# OS

## 内存什么构成

DRAM+辅助电路（地址译码器，数据缓冲器，时序控制）

## Linux系统的文件系统是什么结构，Linux中OS如何解析一个地址的？

树形结构。从根目录逐层查找inode的编号。

## 内核态，用户态

内核态能够运行内核代码并有所有硬件的访问权限。用户态只能通过系统调用才能使用内核服务。

两者切换主要就是系统调用。

主要为了能隔离用户程序直接运行硬件操作，防止系统被破坏；这样还能又内核同一调度资源。

比如，当用户程序调用`open()`函数打开文件时，会通过系统调用陷入内核态，由内核执行实际的文件打开操作后返回用户态。

## 中断在Linux中的一个使用？

比如一个Linux系统，网卡收到以太网帧，他会实现一次硬件中断，将数据通过DMA拷贝到内存。

然后内核会触发一个软件中断，给内存接收队列中的数据包分配数据包处理例程。

## 死锁产生条件（解决方法）

1. 互斥（SPOOLING技术）
2. 不可剥夺（剥夺资源）
3. 请求并且保持（一次性分配）
4. 循环等待（有序分配）

# CPP

## cin和scanf

cin使用了面向对象的思想，把输入封装在cin对象里；scanf纯纯面向过程

cin会类型安全检查；scanf依靠格式控制字符指定输入

cin遇到空白符停止，要用getline读空白符；scanf可以通过格式控制字符来读

cin基于对象，处理大量数据时速度慢于scanf

## C++模板的优点

代码重用。

类型安全，在编译时就会报错，不会到运行时出错结果难debug。

## 虚函数的底层实现机制

使用一个隐藏的虚函数表指针指向虚函数表，子类继承的时候可以重写虚函数（覆盖了原本的虚函数表中的虚函数指针）。要使用虚函数时就动态地通过虚函数表指针查找这张虚函数表即可。

虚函数是**动态（运行时重载）的**多态，函数/运算符重载是**静态（编译时重载）**的多态

缺点就是每个子类都有虚函数表，越继承这玩意越大，占空间。

## cpp，stl库中的sort函数的底层实现？

sort函数底层是结合了**快速排序、堆排序和插入排序的混合排序算法**。他先快速排序，然后检查递归的深度，如果过于深了，就会转向堆排序。如果数据少于16个就会使用插入排序，这样性能好。

## stl库中的map与unordered_map的区别，以及底层实现机制？

map、set都是使用平衡二叉搜索树（红黑树），key是有序的，时间复杂度都是O(logn)

unordered_map、unordered_set都是用哈希表，key是无序的，时间复杂度都是O(n)

## cpp的反射机制？

反射机制：程序在运行时确定一些对象的类型和属性，这样在运行时候能根据不同的条件调整行为。

使用typeid返回对象的信息，使用dynamic_cast进行安全的向下转型。主要是用这两个在cpp中实现反射机制，具体反射机制不像java、py有现成的，要自己手动实现。

# python

## python的缺点是什么，python为啥现在这么受欢迎

python的缺点是解释性语言，执行效率低。变量运行时确定，可能有什么传参错误之类的问题。内存占用比较大。比较依赖第三方的库。

优点：很好上手。社区比较活跃，生态系统强大，有丰富的库和完善的工具（比如说pip，虚拟环境等等）。

## python中算矩阵的秩是怎么算的

使用奇异值分解，分解为三个矩阵乘积，前后为正交矩阵（列向量和行向量为AA^T^和A^T^A的特征向量），中间为对角矩阵，对角上都是奇异值，可能带小数点不准确，有多少个非零（或者说在0附近设置一个阈值，在这个阈值之外的）的奇异值，就是秩的值

# 机器学习

## 机器学习有哪些经典的算法

线性模型：线性回归，逻辑回归

树模型：随机森林，XGBoost，LightGBM

支持向量机

朴素贝叶斯

KNN

K-means，DBSCAN，PCA

CNN，RNN，Transformer

## 哪些分类算法

逻辑回归，SVM，随机森林，梯度提升树（XGBoost，LightBGM），朴素贝叶斯，KNN

CNN，RNN，LSTM，MLP

## 预训练和预处理

预训练是对模型参数训练，使用无监督/子监督学习的办法让模型学习通用特征

预处理是对原始数据进行清洗、转换和特征工程，使其更适合模型的输入

## CNN的特点

- 局部感知：神经元只接受局部区域的输入，减少参数
- 有多层结构自动提取低级（边缘）到高级（物体）特征，提升抽象能力
- 并行高效，适合GPU

## 什么场景下使用SVM更好，什么场景下使用NN好一些？

SVM：小样本高维数据，线性/简单的非线性问题，计算需求小，能解释，适用于文本分类

NN：大规模数据和复杂模式，序列数据，多模态，计算需求大，不能解释，适用于cv，nlp，语音识别

| **场景**           | **SVM**            | **神经网络**                   |
| ------------------ | ------------------ | ------------------------------ |
| **实时性要求高**   | 优先（推理速度快） | 需优化（依赖硬件或模型压缩）   |
| **小样本高维数据** | 精确度更高         | 易过拟合，需数据增强或迁移学习 |
| **大规模复杂数据** | 速度与精确度均下降 | 优势显著（如 ImageNet 分类）   |
| **硬件资源有限**   | 更友好（CPU 即可） | 需 GPU/TPU 加速                |

## 介绍一下支持向量机和神经网络模型的速度和精确度差异

SVM：O(n^3^)，慢，不支持大规模数据

NN：并行化，在GPU下快，尤其是大规模数据

SVM：不容易过拟合

NN：依赖正则化防止过拟合，但是泛化能力强

## 优化器是什么，有哪些优化器

优化器是通过迭代调整模型参数，让损失函数最小的核心算法。

梯度下降，随机梯度下降，Adam，动量优化（引入动量项累积历史梯度方向，抑制震荡，加速收敛）

## 解释梯度消失和梯度爆炸

梯度消失：在NN的反向传播的过程中，梯度随着网络层数的增加而越来越小，导致输入层的神经元权重更新非常慢

原因：网络层数过大；用Sigmoid这种激活函数在多层NN中梯度会逐渐消失

解决：对每一层输入进行归一化，均值为0，方差为1；合适的激活函数（Relu）

梯度爆炸：与梯度消失相反，梯度随着网络层数的增加而变得越来越大，模型参数无法收敛

原因：学习率太大；NN权重设置得太大；NN结构不合理

解决：梯度裁剪；降低学习率

## rnn为什么梯度消失

## resnet原理

**给神经网络加 “捷径”，让深层网络更容易训练。**（就像高速公路上的 “应急车道”，堵车时（梯度消失）能快速传递信息）。 给每层网络加一条 “捷径”（跳跃连接），让信息能跨层直接传递，避免 “堵车”。

## MoE的话可以看一下，毕竟deepseek用了

通过集成多个子模型来处理复杂任务，主要是将不同的输入样本分配给最适合的子模型来处理。

## AI如何应用在安全领域

比如可以使用CNN/RNN来分析二进制文件/PE头，识别恶意代码特征来分析恶意软件。

利用强化学习模拟程序行为，检测异常操作，LSTM 分类恶意软件

比如可以使用无监督模型检测异常流量。

## bert和gpt的区别

**BERT**：基于 Transformer 的**编码器**部分构建，通过堆叠多层编码器来生成深度的双向语言表征。由于采用双向架构，它在处理一个单词时，能够同时利用该单词前后的上下文信息 。

- 训练方式是双向预训练，能同时考虑前后文信息。
- 适用于需要对整个文本进行深度理解的任务，如情感分析、命名实体识别、问答系统、文本分类、句子关系判断等判别式任务。
- 相对模型规模较小，训练和推断时所需的计算资源也较少，在资源受限的环境中也能较好应用

**GPT**：基于 Transformer 的**解码器**部分，采用单向架构，从左到右生成文本，在生成某个单词时，只能依赖该单词之前的上文信息。

- 根据上文内容来预测下一个出现的词语
- 更适合各种生成式的 NLP 任务，如文本生成、机器翻译、对话系统、故事创作、文章续写等。
- 通常模型规模较大，参数更多，尤其是后续版本（如 GPT-3、GPT-4 ），需要大量的计算资源和数据进行训练和推断。

## 最近GPT很火，你对gpt的原理有所了解吗？

GPT是基于深度学习的自然语言处理模型，采用transformer的解码器结构，通过自注意力机制来理解上下文。参数规模特别大的时候，会有复杂推理能力，理解抽象的概念。

## 用没用过chatgpt，觉得chatgpt有什么缺点？

云计算，所以有个人数据泄露的风险，以及云计算资源容易出现高峰时段的访问超载问题。

生成虚假信息，但是显得很真。

# 其他

## 如果实验结果与预期不符合，你会怎么做

预期毕竟只是预期，这个预期只有在实验条件、数据获取、模型构建、参数拟合都与已有实验结果一致，或者与我所设想的理想条件基本相符时才能达到。但是我们都知道，实验过程中有太多的不确定性，哪一个步骤都可能出现意想不到的问题，所以实验结果与预期不相符简直太正常了。

如果遇到这种情况，我会首先从数据收集和预处理阶段开始检查，看看是否有因为粗心造成的错误，然后检查模型代码，看看一些必要的参数先验条件是否考虑充分，参数范围设置是否合理。

如果整个试验过程都没有问题的话，我会再尝试几种拟合方法，进行结果比较。如果几种方法的结果均相似，且与预想不同的话，那么就分析我们的试验与文献有哪些区别，造成结果不同的因素可能有哪些，我认为这是一篇不错的文章；

如果几种方法的结果差异较大，那么就要分析不同方法的适用性问题，结合文献找出某种或某几种方法的适用条件，并考虑使用其他可获取数据进行验证，将结论写成文章，我觉得对于未来其他进行相似研究的人，也有不错的借鉴作用。

## 印象最深的一道信息安全题目

一道印象深刻的 Web 安全题目。题目是获取管理员密码，表面上看是常见的SQL注入漏洞，实际却设置了多重防护，包括 Web 应用防火墙 拦截和自定义的安全策略，常规的注入 Payload 均被过滤。通过仔细分析网站结构，我发现了一个隐藏的备份文件路径。这个备份文件中包含了数据库配置信息，通过解析配置文件，我成功绕过 WAF 限制，直接获取了数据库连接权限。最终，通过查询管理员表得到了加密密码，并利用彩虹表破解了明文。

最近的一个雷蛇漏洞：用户连接雷蛇鼠标时，系统会自动从服务器下载驱动程序并以system执行。在安装界面，用户仅需简单的在安装目录打开PowerShell，就能以system的权限来执行任意命令。即使攻击者没有雷蛇鼠标，也能通过伪造USB ID的方式触发漏洞提权。

## 你为什么做这个项目

kaggle机器学习为了了解火热的机器学习赛道，展示自己有一定的学习能力。

dpdm是为了了解科研。

防火墙是代码能力。

## 你做过最印象深刻的project是什么？

kaggle机器学习

## 本科的一次成功的经历,遗憾的经历

成功的经历还是这个kaggle机器学习的项目，在复试之前效率提升了。

遗憾的话就是篮球队败北。

## 本科最喜欢的课程



## 看过最高层次的论文是什么



## 最近看了什么论文,复述一下



## 网络安全的顶会有哪些?

CCS（ACM Conference on Computer and Communications Security）

NDSS（Network and Distributed System Security Symposium）

S&P（IEEE Symposium on Security & Privacy）

USENIX（USENIX Security Symposium）

其他还有美密、欧密和亚密

## 优缺点

优点是比较专注，动手能力强，想到什么会立刻去实现

缺点是我个人比较内向

## 会不会考虑读博士

当然会，如果我在硕士期间有很好的科研能力。

## 为什么选择这个方向？

我本科方面就是网安与密码，这个方向的老师们做一些多方安全计算还有密码学这些比较契合我。而且我对这方面也比较感兴趣。为什么不去密码学？老师风评不是很好

## 研究生规划，打算研究什么方向，相关的术语的解释以及有哪些实际应用



## 为什么选择复旦

首先，带我学习编程和可以算作我在计算机领域的领路人学长就来自复旦，他还在邱锡鹏老师的实验室搞过ai，这让我对复旦有了很深的向往。我在高考时离复旦差之毫厘，所以也产生了一定的执念。

其次，复旦毫无疑问是一所优秀的大学，有丰富的资源和较高的平台让我学习成长，能让我有足够的专业能力。

最后就是，作为一个理工科的学生，本科学校也是比较崇尚技术能力的，我其实很想体验一下复旦的人文气息，感受一下“自由而无用”，不过我还是更希望能借着在这里成为一个能够博学而笃志、切问而近思的人。

# 数学

## 矩阵秩的定义，向量组秩的定义

矩阵的秩是其行向量组或列向量组的极大线性无关组的向量个数，向量组的秩是其极大线性无关组的向量个数。

## 范德蒙德行列式

可以用来设计纠错码

## 线性空间（向量空间）的定义

一个线性空间的所有向量应该能用这个空间的基向量线性表示

## 如何判断一个数是不是素数

- **费马小定理**：若 p 是素数，对任意 $a \not\equiv 0 \mod p$，有 $a^{p-1} \equiv 1 \mod p$。
- **二次探测**：若 p 是奇素数，且 $x^2 \equiv 1 \mod p$，则 $x \equiv 1 \mod p$ 或 $x \equiv -1 \mod p$。

### 试除法（不大的素数）

### 线性筛（生成小于n的所有素数）

- **唯一筛除**：每个合数仅被其最小素因子筛除一次。
- **维护素数列表**：遍历每个数 i，若未被标记为合数，则将其加入素数列表。
- **标记合数**：用已找到的素数乘以 i，标记为合数。当 i 能被当前素数整除时，停止筛除，避免重复。

### Fermat 素性检测（大素数，有大概率判断）

1. **输入**：待检测的正整数 n，以及一个可选的参数 k（表示进行检测的次数，k 越大，结果越准确）。
2. **特殊情况处理：**
   - 如果 $n = 2$ 或 $n = 3$，则直接判定 n 为素数。
   - 如果 $1\leq n$ 或者 n 是偶数且 $n\neq2$，则判定 n 为合数。
3. **进行 k 次检测：**
   - 随机选取 k 个整数 a，满足 $1 < a < n - 1$。
   - 对于每个选取的 a，计算 $a^{n - 1}\bmod n$。可以使用**快速幂**算法来高效地计算幂模运算。
   - 如果存在某个 a 使得 $a^{n - 1}\not\equiv1\pmod{n}$，则判定 n 为合数。**（费马小定理）**
   - 如果对于所有选取的 a 都有 $a^{n - 1}\equiv1\pmod{n}$，则判定 n 可能是素数。

### Miller-Rabin素性检测

给定奇数 \(n > 2\)，检测其是否为素数：

1. **分解 \(n-1\)**：将 \(n-1\) 表示为 $d \cdot 2^s$，其中 d 是奇数。
2. **选择随机基数 a**：$2 \leq a < n$。
3. **计算 $x = a^d \mod n$：**
   - 若 $x \equiv 1 \mod n$，通过测试，继续下一个 a。**(费马小定理)**
   - 否则，进行s次平方迭代：
     - 若某次迭代后 $x \equiv -1 \mod n$，通过测试，继续下一个 a。**（二次探测）**
     - 若所有迭代均未得到 $x \equiv -1 \mod n$，则 n 是合数。
4. **重复步骤 2-3**：选择多个不同的 a，若所有测试均通过，则 n 大概率是素数。

| **算法**                | **时间复杂度**    | **空间复杂度** | **适用场景**           | **优缺点**                                 |
| ----------------------- | ----------------- | -------------- | ---------------------- | ------------------------------------------ |
| **线性筛**              | \(O(n)\)          | \(O(n)\)       | 生成范围内所有素数     | 高效生成素数表，但内存受限，无法处理大数。 |
| **试除法**              | \(O(\sqrt{n})\)   | \(O(1)\)       | 小规模素数检测或预处理 | 简单准确，但对大数完全不可行。             |
| **Fermat/Miller-Rabin** | \(O(k \log^3 n)\) | \(O(1)\)       | 大素数快速检测         | 高效且错误率可控，但存在理论误判风险。     |